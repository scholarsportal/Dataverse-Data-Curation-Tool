{"ast":null,"code":"import { isPlatformBrowser, DOCUMENT } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, inject, PLATFORM_ID, NgZone, Injectable, SecurityContext, LOCALE_ID, Component, Inject, Optional, Input, Directive, HostListener, NgModule, SkipSelf } from '@angular/core';\nimport * as i1 from '@angular/platform-browser';\nimport { fromEvent, merge } from 'rxjs';\nfunction requireNonNull(value, message) {\n  if (value === null || value === undefined) {\n    throw new Error('Unexpected ' + value + ' value: ' + message);\n  }\n  return value;\n}\n/** Coerce a data-bound value to a boolean */\nfunction coerceCssSizeBinding(value) {\n  if (value == null) {\n    return '';\n  }\n  return typeof value === 'string' ? value : `${value}px`;\n}\nconst CONFIG_NOT_FOUND = 'No Matomo configuration found! Have you included Matomo module using NgxMatomoTrackerModule.forRoot() ?';\n/** Injection token for {@link MatomoConfiguration} */\nconst MATOMO_CONFIGURATION = new InjectionToken('MATOMO_CONFIGURATION');\n/**\n * For internal use only. Injection token for {@link InternalMatomoConfiguration}\n *\n */\nconst INTERNAL_MATOMO_CONFIGURATION = new InjectionToken('INTERNAL_MATOMO_CONFIGURATION', {\n  factory: () => ({\n    disabled: false,\n    enableLinkTracking: true,\n    trackAppInitialLoad: false,\n    requireConsent: MatomoConsentMode.NONE,\n    enableJSErrorTracking: false,\n    runOutsideAngularZone: false,\n    ...requireNonNull(inject(MATOMO_CONFIGURATION, {\n      optional: true\n    }), CONFIG_NOT_FOUND)\n  })\n});\nvar MatomoInitializationMode = /*#__PURE__*/function (MatomoInitializationMode) {\n  /** Automatically inject matomo script using provided configuration */\n  MatomoInitializationMode[MatomoInitializationMode[\"AUTO\"] = 0] = \"AUTO\";\n  /** Do not inject Matomo script. In this case, initialization script must be provided */\n  MatomoInitializationMode[MatomoInitializationMode[\"MANUAL\"] = 1] = \"MANUAL\";\n  /**\n   * Automatically inject matomo script when deferred tracker configuration is provided using `MatomoDeferredInitializerService.init`.\n   */\n  MatomoInitializationMode[MatomoInitializationMode[\"AUTO_DEFERRED\"] = 2] = \"AUTO_DEFERRED\";\n  return MatomoInitializationMode;\n}(MatomoInitializationMode || {});\nvar MatomoConsentMode = /*#__PURE__*/function (MatomoConsentMode) {\n  /** Do not require any consent, always track users */\n  MatomoConsentMode[MatomoConsentMode[\"NONE\"] = 0] = \"NONE\";\n  /** Require cookie consent */\n  MatomoConsentMode[MatomoConsentMode[\"COOKIE\"] = 1] = \"COOKIE\";\n  /** Require tracking consent */\n  MatomoConsentMode[MatomoConsentMode[\"TRACKING\"] = 2] = \"TRACKING\";\n  return MatomoConsentMode;\n}(MatomoConsentMode || {});\nfunction isAutoConfigurationMode(config) {\n  return config.mode == null || config.mode === MatomoInitializationMode.AUTO;\n}\nfunction hasMainTrackerConfiguration(config) {\n  // If one is undefined, both should be\n  return config.siteId != null && config.trackerUrl != null;\n}\nfunction isEmbeddedTrackerConfiguration(config) {\n  return config.scriptUrl != null && !hasMainTrackerConfiguration(config);\n}\nfunction isExplicitTrackerConfiguration(config) {\n  return hasMainTrackerConfiguration(config) || isMultiTrackerConfiguration(config);\n}\nfunction isMultiTrackerConfiguration(config) {\n  return Array.isArray(config.trackers);\n}\nfunction getTrackersConfiguration(config) {\n  return isMultiTrackerConfiguration(config) ? config.trackers : [{\n    trackerUrl: config.trackerUrl,\n    siteId: config.siteId,\n    trackerUrlSuffix: config.trackerUrlSuffix\n  }];\n}\nfunction initializeMatomoHolder() {\n  window._paq = window._paq || [];\n}\nfunction trimTrailingUndefinedElements(array) {\n  const trimmed = [...array];\n  while (trimmed.length > 0 && trimmed[trimmed.length - 1] === undefined) {\n    trimmed.pop();\n  }\n  return trimmed;\n}\nfunction isECommerceCategoryView(param) {\n  return typeof param === 'object' && Object.keys(param).length === 1 && param.productCategory != null;\n}\nfunction isECommerceItemView(param) {\n  return typeof param === 'object' && 'productSKU' in param;\n}\nfunction createMatomoTracker(config, platformId, ngZone) {\n  return config.disabled || !isPlatformBrowser(platformId) ? new NoopMatomoTracker() : new StandardMatomoTracker(ngZone, config);\n}\nlet MatomoTracker = /*#__PURE__*/(() => {\n  class MatomoTracker {\n    /**\n     * Logs a visit to this page.\n     *\n     * @param [customTitle] Optional title of the visited page.\n     */\n    trackPageView(customTitle) {\n      this.push(['trackPageView', customTitle]);\n    }\n    /**\n     * Logs an event with an event category (Videos, Music, Games…), an event action (Play, Pause, Duration,\n     * Add Playlist, Downloaded, Clicked…), and an optional event name and optional numeric value.\n     *\n     * @param category Category of the event.\n     * @param action Action of the event.\n     * @param [name] Optional name of the event.\n     * @param [value] Optional value for the event.\n     */\n    trackEvent(category, action, name, value) {\n      this.push(['trackEvent', category, action, name, value]);\n    }\n    /**\n     * Logs an internal site search for a specific keyword, in an optional category,\n     * specifying the optional count of search results in the page.\n     *\n     * @param keyword Keywords of the search query.\n     * @param [category] Optional category of the search query.\n     * @param [resultsCount] Optional number of results returned by the search query.\n     */\n    trackSiteSearch(keyword, category, resultsCount) {\n      this.push(['trackSiteSearch', keyword, category, resultsCount]);\n    }\n    /**\n     * Manually logs a conversion for the numeric goal ID, with an optional numeric custom revenue customRevenue.\n     *\n     * @param idGoal numeric ID of the goal to log a conversion for.\n     * @param [customRevenue] Optional custom revenue to log for the goal.\n     */\n    trackGoal(idGoal, customRevenue) {\n      this.push(['trackGoal', idGoal, customRevenue]);\n    }\n    /**\n     * Manually logs a click from your own code.\n     *\n     * @param url Full URL which is to be tracked as a click.\n     * @param linkType Either 'link' for an outlink or 'download' for a download.\n     */\n    trackLink(url, linkType) {\n      this.push(['trackLink', url, linkType]);\n    }\n    /**\n     * Scans the entire DOM for all content blocks and tracks all impressions once the DOM ready event has been triggered.\n     *\n     */\n    trackAllContentImpressions() {\n      this.push(['trackAllContentImpressions']);\n    }\n    /**\n     * Scans the entire DOM for all content blocks as soon as the page is loaded.<br />\n     * It tracks an impression only if a content block is actually visible.\n     *\n     * @param checkOnScroll If true, checks for new content blocks while scrolling the page.\n     * @param timeInterval Duration, in milliseconds, between two checks upon scroll.\n     */\n    trackVisibleContentImpressions(checkOnScroll, timeInterval) {\n      this.push(['trackVisibleContentImpressions', checkOnScroll, timeInterval]);\n    }\n    /**\n     * Scans the given DOM node and its children for content blocks and tracks an impression for them\n     * if no impression was already tracked for it.\n     *\n     * @param node DOM node in which to look for content blocks which have not been previously tracked.\n     */\n    trackContentImpressionsWithinNode(node) {\n      this.push(['trackContentImpressionsWithinNode', node]);\n    }\n    /**\n     * Tracks an interaction with the given DOM node/content block.\n     *\n     * @param node DOM node for which to track a content interaction.\n     * @param contentInteraction Name of the content interaction.\n     */\n    trackContentInteractionNode(node, contentInteraction) {\n      this.push(['trackContentInteractionNode', node, contentInteraction]);\n    }\n    /**\n     * Tracks a content impression using the specified values.\n     *\n     * @param contentName Content name.\n     * @param contentPiece Content piece.\n     * @param contentTarget Content target.\n     */\n    trackContentImpression(contentName, contentPiece, contentTarget) {\n      this.push(['trackContentImpression', contentName, contentPiece, contentTarget]);\n    }\n    /**\n     * Tracks a content interaction using the specified values.\n     *\n     * @param contentInteraction Content interaction.\n     * @param contentName Content name.\n     * @param contentPiece Content piece.\n     * @param contentTarget Content target.\n     */\n    trackContentInteraction(contentInteraction, contentName, contentPiece, contentTarget) {\n      this.push(['trackContentInteraction', contentInteraction, contentName, contentPiece, contentTarget]);\n    }\n    /**\n     * Logs all found content blocks within a page to the console. This is useful to debug / test content tracking.\n     */\n    logAllContentBlocksOnPage() {\n      this.push(['logAllContentBlocksOnPage']);\n    }\n    /**\n     * Send a ping request\n     * <p>\n     * Ping requests do not track new actions.\n     * If they are sent within the standard visit length, they will update the existing visit time.\n     * If sent after the standard visit length, ping requests will be ignored.\n     * See also {@link #enableHeartBeatTimer enableHeartBeatTimer()}.\n     *\n     * @see enableHeartBeatTimer\n     */\n    ping() {\n      this.push(['ping']);\n    }\n    /**\n     * Install a Heart beat timer that will regularly send requests to Matomo in order to better measure the time spent on the page.<br />\n     * These requests will be sent only when the user is actively viewing the page (when the tab is active and in focus).<br />\n     * These requests will not track additional actions or page views.<br />\n     * By default, the delay is set to 15 seconds.\n     *\n     * @param delay Delay, in seconds, between two heart beats to the server.\n     */\n    enableHeartBeatTimer(delay) {\n      this.push(['enableHeartBeatTimer', delay]);\n    }\n    /**\n     * Installs link tracking on all applicable link elements.\n     *\n     * @param usePseudoClickHandler Set to `true` to use pseudo click-handler (treat middle click and open contextmenu as\n     * left click).<br />\n     * A right click (or any click that opens the context menu) on a link will be tracked as clicked even if \"Open in new tab\"\n     * is not selected.<br />\n     * If \"false\" (default), nothing will be tracked on open context menu or middle click.\n     */\n    enableLinkTracking(usePseudoClickHandler = false) {\n      this.push(['enableLinkTracking', usePseudoClickHandler]);\n    }\n    /** Disables page performance tracking */\n    disablePerformanceTracking() {\n      this.push(['disablePerformanceTracking']);\n    }\n    /**\n     * Enables cross domain linking. By default, the visitor ID that identifies a unique visitor is stored in the browser's\n     * first party cookies.<br />\n     * This means the cookie can only be accessed by pages on the same domain.<br />\n     * If you own multiple domains and would like to track all the actions and pageviews of a specific visitor into the same visit,\n     * you may enable cross domain linking.<br />\n     * Whenever a user clicks on a link it will append a URL parameter pk_vid to the clicked URL which forwards the current\n     * visitor ID value to the page of the different domain.\n     *\n     */\n    enableCrossDomainLinking() {\n      this.push(['enableCrossDomainLinking']);\n    }\n    /**\n     * By default, the two visits across domains will be linked together when the link is clicked and the page is loaded within\n     * a 180 seconds timeout window.\n     *\n     * @param timeout Timeout, in seconds, between two actions across two domains before creating a new visit.\n     */\n    setCrossDomainLinkingTimeout(timeout) {\n      this.push(['setCrossDomainLinkingTimeout', timeout]);\n    }\n    /**\n     * Get the query parameter to append to links to handle cross domain linking.\n     *\n     * Use this to add cross domain support for links that are added to the DOM dynamically\n     */\n    getCrossDomainLinkingUrlParameter() {\n      return this.get('getCrossDomainLinkingUrlParameter');\n    }\n    /**\n     * Overrides document.title\n     *\n     * @param title Title of the document.\n     */\n    setDocumentTitle(title) {\n      this.push(['setDocumentTitle', title]);\n    }\n    /**\n     * Set array of hostnames or domains to be treated as local.<br />\n     * For wildcard subdomains, you can use: `setDomains('.example.com')`; or `setDomains('*.example.com');`.<br />\n     * You can also specify a path along a domain: `setDomains('*.example.com/subsite1');`.\n     *\n     * @param domains List of hostnames or domains, with or without path, to be treated as local.\n     */\n    setDomains(domains) {\n      this.push(['setDomains', domains]);\n    }\n    /**\n     * Override the page's reported URL.\n     *\n     * @param url URL to be reported for the page.\n     */\n    setCustomUrl(url) {\n      this.push(['setCustomUrl', url]);\n    }\n    /**\n     * Overrides the detected Http-Referer.\n     *\n     * @param url URL to be reported for the referer.\n     */\n    setReferrerUrl(url) {\n      this.push(['setReferrerUrl', url]);\n    }\n    /**\n     * Specifies the website ID.<br />\n     * Redundant: can be specified in getTracker() constructor.\n     *\n     * @param siteId Site ID for the tracker.\n     */\n    setSiteId(siteId) {\n      this.push(['setSiteId', siteId]);\n    }\n    /**\n     * Specify the Matomo HTTP API URL endpoint. Points to the root directory of matomo,\n     * e.g. http://matomo.example.org/ or https://example.org/matomo/.<br />\n     * This function is only useful when the 'Overlay' report is not working.<br />\n     * By default, you do not need to use this function.\n     *\n     * @param url URL for Matomo HTTP API endpoint.\n     */\n    setApiUrl(url) {\n      this.push(['setApiUrl', url]);\n    }\n    /**\n     * Specifies the Matomo server URL.<br />\n     * Redundant: can be specified in getTracker() constructor.\n     *\n     * @param url URL for the Matomo server.\n     */\n    setTrackerUrl(url) {\n      this.push(['setTrackerUrl', url]);\n    }\n    /**\n     * Register an additional Matomo server<br />\n     * Redundant: can be specified in getTracker() constructor.\n     *\n     * @param url URL for the Matomo server.\n     * @param siteId Site ID for the tracker\n     */\n    addTracker(url, siteId) {\n      this.push(['addTracker', url, siteId]);\n    }\n    /**\n     * Returns the Matomo server URL.\n     *\n     * @returns Promise for the Matomo server URL.\n     */\n    getMatomoUrl() {\n      return this.get('getMatomoUrl');\n    }\n    /**\n     * Returns the current url of the page that is currently being visited.<br />\n     * If a custom URL was set before calling this method, the custom URL will be returned.\n     *\n     * @returns Promise for the URL of the current page.\n     */\n    getCurrentUrl() {\n      return this.get('getCurrentUrl');\n    }\n    /**\n     * Set classes to be treated as downloads (in addition to piwik_download).\n     *\n     * @param classes Class, or list of classes to be treated as downloads.\n     */\n    setDownloadClasses(classes) {\n      this.push(['setDownloadClasses', classes]);\n    }\n    /**\n     * Set list of file extensions to be recognized as downloads.<br />\n     * Example: `'docx'` or `['docx', 'xlsx']`.\n     *\n     * @param extensions Extension, or list of extensions to be recognized as downloads.\n     */\n    setDownloadExtensions(extensions) {\n      this.push(['setDownloadExtensions', extensions]);\n    }\n    /**\n     * Set additional file extensions to be recognized as downloads.<br />\n     * Example: `'docx'` or `['docx', 'xlsx']`.\n     *\n     * @param extensions Extension, or list of extensions to be recognized as downloads.\n     */\n    addDownloadExtensions(extensions) {\n      this.push(['addDownloadExtensions', extensions]);\n    }\n    /**\n     * Set file extensions to be removed from the list of download file extensions.<br />\n     * Example: `'docx'` or `['docx', 'xlsx']`.\n     *\n     * @param extensions Extension, or list of extensions not to be recognized as downloads.\n     */\n    removeDownloadExtensions(extensions) {\n      this.push(['removeDownloadExtensions', extensions]);\n    }\n    /**\n     * Set classes to be ignored if present in link (in addition to piwik_ignore).\n     *\n     * @param classes Class, or list of classes to be ignored if present in link.\n     */\n    setIgnoreClasses(classes) {\n      this.push(['setIgnoreClasses', classes]);\n    }\n    /**\n     * Set classes to be treated as outlinks (in addition to piwik_link).\n     *\n     * @param classes Class, or list of classes to be treated as outlinks.\n     */\n    setLinkClasses(classes) {\n      this.push(['setLinkClasses', classes]);\n    }\n    /**\n     * Set delay for link tracking (in milliseconds).\n     *\n     * @param delay Delay, in milliseconds, for link tracking.\n     */\n    setLinkTrackingTimer(delay) {\n      this.push(['setLinkTrackingTimer', delay]);\n    }\n    /**\n     * Returns delay for link tracking.\n     *\n     * @returns Promise for the delay in milliseconds.\n     */\n    getLinkTrackingTimer() {\n      return this.get('getLinkTrackingTimer');\n    }\n    /**\n     * Set to true to not record the hash tag (anchor) portion of URLs.\n     *\n     * @param value If true, the hash tag portion of the URLs won't be recorded.\n     */\n    discardHashTag(value) {\n      this.push(['discardHashTag', value]);\n    }\n    /**\n     * By default, Matomo uses the browser DOM Timing API to accurately determine the time it takes to generate and download\n     * the page. You may overwrite this value with this function.\n     *\n     * <b>This feature has been deprecated since Matomo 4. Any call will be ignored with Matomo 4. Use {@link setPagePerformanceTiming setPagePerformanceTiming()} instead.</b>\n     *\n     * @param generationTime Time, in milliseconds, of the page generation.\n     */\n    setGenerationTimeMs(generationTime) {\n      this.push(['setGenerationTimeMs', generationTime]);\n    }\n    setPagePerformanceTiming(networkTimeInMsOrTimings, serverTimeInMs, transferTimeInMs, domProcessingTimeInMs, domCompletionTimeInMs, onloadTimeInMs) {\n      let networkTimeInMs;\n      if (typeof networkTimeInMsOrTimings === 'object' && !!networkTimeInMsOrTimings) {\n        networkTimeInMs = networkTimeInMsOrTimings.networkTimeInMs;\n        serverTimeInMs = networkTimeInMsOrTimings.serverTimeInMs;\n        transferTimeInMs = networkTimeInMsOrTimings.transferTimeInMs;\n        domProcessingTimeInMs = networkTimeInMsOrTimings.domProcessingTimeInMs;\n        domCompletionTimeInMs = networkTimeInMsOrTimings.domCompletionTimeInMs;\n        onloadTimeInMs = networkTimeInMsOrTimings.onloadTimeInMs;\n      } else {\n        networkTimeInMs = networkTimeInMsOrTimings;\n      }\n      this.push(['setPagePerformanceTiming', networkTimeInMs, serverTimeInMs, transferTimeInMs, domProcessingTimeInMs, domCompletionTimeInMs, onloadTimeInMs]);\n    }\n    getCustomPagePerformanceTiming() {\n      return this.get('getCustomPagePerformanceTiming');\n    }\n    /**\n     * Appends a custom string to the end of the HTTP request to matomo.php.\n     *\n     * @param appendToUrl String to append to the end of the HTTP request to matomo.php.\n     */\n    appendToTrackingUrl(appendToUrl) {\n      this.push(['appendToTrackingUrl', appendToUrl]);\n    }\n    /** Set to `true` to not track users who opt out of tracking using <i>Do Not Track</i> setting */\n    setDoNotTrack(doNotTrack) {\n      this.push(['setDoNotTrack', doNotTrack]);\n    }\n    /**\n     * Enables a frame-buster to prevent the tracked web page from being framed/iframed.\n     */\n    killFrame() {\n      this.push(['killFrame']);\n    }\n    /**\n     * Forces the browser to load the live URL if the tracked web page is loaded from a local file\n     * (e.g., saved to someone's desktop).\n     *\n     * @param url URL to track instead of file:// URLs.\n     */\n    redirectFile(url) {\n      this.push(['redirectFile', url]);\n    }\n    /**\n     * Records how long the page has been viewed if the minimumVisitLength is attained;\n     * the heartBeatDelay determines how frequently to update the server.\n     *\n     * @param minimumVisitLength Duration before notifying the server for the duration of the visit to a page.\n     * @param heartBeatDelay Delay, in seconds, between two updates to the server.\n     */\n    setHeartBeatTimer(minimumVisitLength, heartBeatDelay) {\n      this.push(['setHeartBeatTimer', minimumVisitLength, heartBeatDelay]);\n    }\n    /**\n     * Returns the 16 characters ID for the visitor.\n     *\n     * @returns Promise for the the 16 characters ID for the visitor.\n     */\n    getVisitorId() {\n      return this.get('getVisitorId');\n    }\n    /**\n     * Set the 16 characters ID for the visitor\n     * <p/>\n     * The visitorId needs to be a 16 digit hex string.\n     * It won't be persisted in a cookie and needs to be set on every new page load.\n     *\n     * @param visitorId a 16 digit hex string\n     */\n    setVisitorId(visitorId) {\n      this.push(['setVisitorId', visitorId]);\n    }\n    /**\n     * Returns the visitor cookie contents in an array.\n     *\n     * @returns Promise for the cookie contents in an array.\n     *\n     * TODO better return type\n     */\n    getVisitorInfo() {\n      return this.get('getVisitorInfo');\n    }\n    /**\n     * Returns the visitor attribution array (Referer information and/or Campaign name & keyword).<br />\n     * Attribution information is used by Matomo to credit the correct referrer (first or last referrer)\n     * used when a user triggers a goal conversion.\n     *\n     * @returns Promise for the visitor attribution array (Referer information and/or Campaign name & keyword).\n     */\n    getAttributionInfo() {\n      return this.get('getAttributionInfo');\n    }\n    /**\n     * Returns the attribution campaign name.\n     *\n     * @returns Promise for the the attribution campaign name.\n     */\n    getAttributionCampaignName() {\n      return this.get('getAttributionCampaignName');\n    }\n    /**\n     * Returns the attribution campaign keyword.\n     *\n     * @returns Promise for the attribution campaign keyword.\n     */\n    getAttributionCampaignKeyword() {\n      return this.get('getAttributionCampaignKeyword');\n    }\n    /**\n     * Returns the attribution referrer timestamp.\n     *\n     * @returns Promise for the attribution referrer timestamp (as string).\n     */\n    getAttributionReferrerTimestamp() {\n      return this.get('getAttributionReferrerTimestamp');\n    }\n    /**\n     * Returns the attribution referrer URL.\n     *\n     * @returns Promise for the attribution referrer URL\n     */\n    getAttributionReferrerUrl() {\n      return this.get('getAttributionReferrerUrl');\n    }\n    /**\n     * Returns the User ID string if it was set.\n     *\n     * @returns Promise for the User ID for the visitor.\n     */\n    getUserId() {\n      return this.get('getUserId');\n    }\n    /**\n     * Set a User ID to this user (such as an email address or a username).\n     *\n     * @param userId User ID to set for the current visitor.\n     */\n    setUserId(userId) {\n      this.push(['setUserId', userId]);\n    }\n    /**\n     * Reset the User ID which also generates a new Visitor ID.\n     *\n     */\n    resetUserId() {\n      this.push(['resetUserId']);\n    }\n    /**\n     * Set a custom variable.\n     *\n     * @param index Index, the number from 1 to 5 where this custom variable name is stored for the current page view.\n     * @param name Name, the name of the variable, for example: Category, Sub-category, UserType.\n     * @param value Value, for example: \"Sports\", \"News\", \"World\", \"Business\"…\n     * @param scope Scope of the custom variable:<br />\n     * - \"page\" means the custom variable applies to the current page view.\n     * - \"visit\" means the custom variable applies to the current visitor.\n     */\n    setCustomVariable(index, name, value, scope) {\n      this.push(['setCustomVariable', index, name, value, scope]);\n    }\n    /**\n     * Deletes a custom variable.\n     *\n     * @param index Index of the custom variable to delete.\n     * @param scope Scope of the custom variable to delete.\n     */\n    deleteCustomVariable(index, scope) {\n      this.push(['deleteCustomVariable', index, scope]);\n    }\n    /**\n     * Deletes all custom variables.\n     *\n     * @param scope Scope of the custom variables to delete.\n     */\n    deleteCustomVariables(scope) {\n      this.push(['deleteCustomVariables', scope]);\n    }\n    /**\n     * Retrieves a custom variable.\n     *\n     * @param index Index of the custom variable to retrieve.\n     * @param scope Scope of the custom variable to retrieve.\n     * @returns Promise for the value of custom variable.\n     */\n    getCustomVariable(index, scope) {\n      return this.pushFn(matomo => matomo.getCustomVariable(index, scope));\n    }\n    /**\n     * When called then the Custom Variables of scope \"visit\" will be stored (persisted) in a first party cookie\n     * for the duration of the visit.<br />\n     * This is useful if you want to call getCustomVariable later in the visit.<br />\n     * (by default custom variables are not stored on the visitor's computer.)\n     *\n     */\n    storeCustomVariablesInCookie() {\n      this.push(['storeCustomVariablesInCookie']);\n    }\n    /**\n     * Set a custom dimension.<br />\n     * (requires Matomo 2.15.1 + Custom Dimensions plugin)\n     *\n     * @param customDimensionId ID of the custom dimension to set.\n     * @param customDimensionValue Value to be set.\n     */\n    setCustomDimension(customDimensionId, customDimensionValue) {\n      this.push(['setCustomDimension', customDimensionId, customDimensionValue]);\n    }\n    /**\n     * Deletes a custom dimension.<br />\n     * (requires Matomo 2.15.1 + Custom Dimensions plugin)\n     *\n     * @param customDimensionId ID of the custom dimension to delete.\n     */\n    deleteCustomDimension(customDimensionId) {\n      this.push(['deleteCustomDimension', customDimensionId]);\n    }\n    /**\n     * Retrieve a custom dimension.<br />\n     * (requires Matomo 2.15.1 + Custom Dimensions plugin)\n     *\n     * @param customDimensionId ID of the custom dimension to retrieve.\n     * @return Promise for the value for the requested custom dimension.\n     */\n    getCustomDimension(customDimensionId) {\n      return this.pushFn(matomo => matomo.getCustomDimension(customDimensionId));\n    }\n    /**\n     * Set campaign name parameter(s).\n     *\n     * @param name Name of the campaign\n     */\n    setCampaignNameKey(name) {\n      this.push(['setCampaignNameKey', name]);\n    }\n    /**\n     * Set campaign keyword parameter(s).\n     *\n     * @param keyword Keyword parameter(s) of the campaign.\n     */\n    setCampaignKeywordKey(keyword) {\n      this.push(['setCampaignKeywordKey', keyword]);\n    }\n    /**\n     * Set to true to attribute a conversion to the first referrer.<br />\n     * By default, conversion is attributed to the most recent referrer.\n     *\n     * @param conversionToFirstReferrer If true, Matomo will attribute the Goal conversion to the first referrer used\n     * instead of the last one.\n     */\n    setConversionAttributionFirstReferrer(conversionToFirstReferrer) {\n      this.push(['setConversionAttributionFirstReferrer', conversionToFirstReferrer]);\n    }\n    setEcommerceView(productOrSKU, productName, productCategory, price) {\n      if (isECommerceCategoryView(productOrSKU)) {\n        this.push(['setEcommerceView', false, false, productOrSKU.productCategory]);\n      } else if (isECommerceItemView(productOrSKU)) {\n        this.push(['setEcommerceView', productOrSKU.productSKU, productOrSKU.productName, productOrSKU.productCategory, productOrSKU.price]);\n      } else {\n        this.push(['setEcommerceView', productOrSKU, productName, productCategory, price]);\n      }\n    }\n    addEcommerceItem(productOrSKU, productName, productCategory, price, quantity) {\n      if (typeof productOrSKU === 'string') {\n        this.push(['addEcommerceItem', productOrSKU, productName, productCategory, price, quantity]);\n      } else {\n        this.push(['addEcommerceItem', productOrSKU.productSKU, productOrSKU.productName, productOrSKU.productCategory, productOrSKU.price, productOrSKU.quantity]);\n      }\n    }\n    /**\n     * Remove the specified product from the untracked ecommerce order\n     *\n     * @param productSKU SKU of the product to remove.\n     */\n    removeEcommerceItem(productSKU) {\n      this.push(['removeEcommerceItem', productSKU]);\n    }\n    /**\n     * Remove all products in the untracked ecommerce order\n     *\n     * Note: This is done automatically after {@link #trackEcommerceOrder trackEcommerceOrder()} is called\n     */\n    clearEcommerceCart() {\n      this.push(['clearEcommerceCart']);\n    }\n    /**\n     * Return all ecommerce items currently in the untracked ecommerce order\n     * <p/>\n     * The returned array will be a copy, so changing it won't affect the ecommerce order.\n     * To affect what gets tracked, use the {@link #addEcommerceItem addEcommerceItem()}, {@link #removeEcommerceItem removeEcommerceItem()},\n     * {@link #clearEcommerceCart clearEcommerceCart()} methods.\n     * Use this method to see what will be tracked before you track an order or cart update.\n     */\n    getEcommerceItems() {\n      return this.get('getEcommerceItems');\n    }\n    /**\n     * Tracks a shopping cart.<br />\n     * Call this function every time a user is adding, updating or deleting a product from the cart.\n     *\n     * @param grandTotal Grand total of the shopping cart.\n     */\n    trackEcommerceCartUpdate(grandTotal) {\n      this.push(['trackEcommerceCartUpdate', grandTotal]);\n    }\n    /**\n     * Tracks an Ecommerce order, including any eCommerce item previously added to the order.<br />\n     * orderId and grandTotal (ie.revenue) are required parameters.\n     *\n     * @param orderId ID of the tracked order.\n     * @param grandTotal Grand total of the tracked order.\n     * @param [subTotal] Sub total of the tracked order.\n     * @param [tax] Taxes for the tracked order.\n     * @param [shipping] Shipping fees for the tracked order.\n     * @param [discount] Discount granted for the tracked order.\n     */\n    trackEcommerceOrder(orderId, grandTotal, subTotal, tax, shipping, discount) {\n      this.push(['trackEcommerceOrder', orderId, grandTotal, subTotal, tax, shipping, discount]);\n    }\n    /**\n     * Require nothing is tracked until a user consents\n     *\n     * By default the Matomo tracker assumes consent to tracking.\n     *\n     * @see `requireConsent` module configuration property\n     */\n    requireConsent() {\n      this.push(['requireConsent']);\n    }\n    /**\n     * Mark that the current user has consented\n     *\n     * The consent is one-time only, so in a subsequent browser session, the user will have to consent again.\n     * To remember consent, see {@link rememberConsentGiven}.\n     */\n    setConsentGiven() {\n      this.push(['setConsentGiven']);\n    }\n    /**\n     * Mark that the current user has consented, and remembers this consent through a browser cookie.\n     *\n     * The next time the user visits the site, Matomo will remember that they consented, and track them.\n     * If you call this method, you do not need to call {@link setConsentGiven}.\n     *\n     * @param hoursToExpire After how many hours the consent should expire. By default the consent is valid\n     *                          for 30 years unless cookies are deleted by the user or the browser prior to this\n     */\n    rememberConsentGiven(hoursToExpire) {\n      this.push(['rememberConsentGiven', hoursToExpire]);\n    }\n    /**\n     * Remove a user's consent, both if the consent was one-time only and if the consent was remembered.\n     *\n     * After calling this method, the user will have to consent again in order to be tracked.\n     */\n    forgetConsentGiven() {\n      this.push(['forgetConsentGiven']);\n    }\n    /** Return whether the current visitor has given consent previously or not */\n    hasRememberedConsent() {\n      return this.get('hasRememberedConsent');\n    }\n    /**\n     * If consent was given, returns the timestamp when the visitor gave consent\n     *\n     * Only works if {@link rememberConsentGiven} was used and not when {@link setConsentGiven} was used.\n     * The timestamp is the local timestamp which depends on the visitors time.\n     */\n    getRememberedConsent() {\n      return this.get('getRememberedConsent');\n    }\n    /** Return whether {@link requireConsent} was called previously */\n    isConsentRequired() {\n      return this.get('isConsentRequired');\n    }\n    /**\n     * Require no cookies are used\n     *\n     * By default the Matomo tracker assumes consent to using cookies\n     */\n    requireCookieConsent() {\n      this.push(['requireCookieConsent']);\n    }\n    /**\n     * Mark that the current user has consented to using cookies\n     *\n     * The consent is one-time only, so in a subsequent browser session, the user will have to consent again.\n     * To remember cookie consent, see {@link rememberCookieConsentGiven}.\n     */\n    setCookieConsentGiven() {\n      this.push(['setCookieConsentGiven']);\n    }\n    /**\n     * Mark that the current user has consented to using cookies, and remembers this consent through a browser cookie.\n     *\n     * The next time the user visits the site, Matomo will remember that they consented, and use cookies.\n     * If you call this method, you do not need to call {@link setCookieConsentGiven}.\n     *\n     * @param hoursToExpire After how many hours the cookie consent should expire. By default the consent is valid\n     *                          for 30 years unless cookies are deleted by the user or the browser prior to this\n     */\n    rememberCookieConsentGiven(hoursToExpire) {\n      this.push(['rememberCookieConsentGiven', hoursToExpire]);\n    }\n    /**\n     * Remove a user's cookie consent, both if the consent was one-time only and if the consent was remembered.\n     *\n     * After calling this method, the user will have to consent again in order for cookies to be used.\n     */\n    forgetCookieConsentGiven() {\n      this.push(['forgetCookieConsentGiven']);\n    }\n    /** Return whether cookies are currently enabled or disabled */\n    areCookiesEnabled() {\n      return this.get('areCookiesEnabled');\n    }\n    /** After calling this function, the user will be opted out and no longer be tracked */\n    optUserOut() {\n      this.push(['optUserOut']);\n    }\n    /** After calling this method the user will be tracked again */\n    forgetUserOptOut() {\n      this.push(['forgetUserOptOut']);\n    }\n    /**\n     * Return whether the user is opted out or not\n     *\n     * Note: This method might not return the correct value if you are using the opt out iframe.\n     */\n    isUserOptedOut() {\n      return this.get('isUserOptedOut');\n    }\n    /**\n     * Disables all first party cookies.<br />\n     * Existing Matomo cookies for this websites will be deleted on the next page view.\n     */\n    disableCookies() {\n      this.push(['disableCookies']);\n    }\n    /**\n     * Deletes the tracking cookies currently set (useful when creating new visits).\n     */\n    deleteCookies() {\n      this.push(['deleteCookies']);\n    }\n    /**\n     * Returns whether cookies are enabled and supported by this browser.\n     *\n     * @returns Promise for the support and activation of cookies.\n     */\n    hasCookies() {\n      return this.get('hasCookies');\n    }\n    /**\n     * Set the tracking cookie name prefix.<br />\n     * Default prefix is 'pk'.\n     *\n     * @param prefix Prefix for the tracking cookie names.\n     */\n    setCookieNamePrefix(prefix) {\n      this.push(['setCookieNamePrefix', prefix]);\n    }\n    /**\n     * Set the domain of the tracking cookies.<br />\n     * Default is the document domain.<br />\n     * If your website can be visited at both www.example.com and example.com, you would use: `'.example.com'` or `'*.example.com'`.\n     *\n     * @param domain Domain of the tracking cookies.\n     */\n    setCookieDomain(domain) {\n      this.push(['setCookieDomain', domain]);\n    }\n    /**\n     * Set the path of the tracking cookies.<br />\n     * Default is '/'.\n     *\n     * @param path Path of the tracking cookies.\n     */\n    setCookiePath(path) {\n      this.push(['setCookiePath', path]);\n    }\n    /**\n     * Set to true to enable the Secure cookie flag on all first party cookies.<br />\n     * This should be used when your website is only available under HTTPS so that all tracking cookies are always sent\n     * over secure connection.\n     *\n     * @param secure If true, the secure cookie flag will be set on all first party cookies.\n     */\n    setSecureCookie(secure) {\n      this.push(['setSecureCookie', secure]);\n    }\n    /**\n     * Set cookie <i>same site</i>\n     * <p/>\n     * Defaults to Lax.\n     * Can be set to None or Strict.\n     * None requires all traffic to be on HTTPS and will also automatically set the secure cookie.\n     * It can be useful for example if the tracked website is an iframe.\n     * Strict only works if your Matomo and the website runs on the very same domain.\n     */\n    setCookieSameSite(sameSite) {\n      this.push(['setCookieSameSite', sameSite]);\n    }\n    /**\n     * Set the visitor cookie timeout.<br />\n     * Default is 13 months.\n     *\n     * @param timeout Timeout, in seconds, for the visitor cookie timeout.\n     */\n    setVisitorCookieTimeout(timeout) {\n      this.push(['setVisitorCookieTimeout', timeout]);\n    }\n    /**\n     * Set the referral cookie timeout.<br />\n     * Default is 6 months.\n     *\n     * @param timeout Timeout, in seconds, for the referral cookie timeout.\n     */\n    setReferralCookieTimeout(timeout) {\n      this.push(['setReferralCookieTimeout', timeout]);\n    }\n    /**\n     * Set the session cookie timeout.<br />\n     * Default is 30 minutes.\n     *\n     * @param timeout Timeout, in seconds, for the session cookie timeout.\n     */\n    setSessionCookieTimeout(timeout) {\n      this.push(['setSessionCookieTimeout', timeout]);\n    }\n    /**\n     * Adds a click listener to a specific link element.<br />\n     * When clicked, Matomo will log the click automatically.\n     *\n     * @param element Element on which to add a click listener.\n     */\n    addListener(element) {\n      this.push(['addListener', element]);\n    }\n    /**\n     * Set the request method to either \"GET\" or \"POST\". (The default is \"GET\".)<br />\n     * To use the POST request method, either:<br />\n     * 1) the Matomo host is the same as the tracked website host (Matomo installed in the same domain as your tracked website), or<br />\n     * 2) if Matomo is not installed on the same host as your website, you need to enable CORS (Cross domain requests).\n     *\n     * @param method HTTP method for sending information to the Matomo server.\n     */\n    setRequestMethod(method) {\n      this.push(['setRequestMethod', method]);\n    }\n    /**\n     * Set a function that will process the request content.<br />\n     * The function will be called once the request (query parameters string) has been prepared, and before the request content is sent.\n     *\n     * @param callback Function that will process the request content.\n     */\n    setCustomRequestProcessing(callback) {\n      this.push(['setCustomRequestProcessing', callback]);\n    }\n    /**\n     * Set request Content-Type header value.<br />\n     * Applicable when \"POST\" request method is used via setRequestMethod.\n     *\n     * @param contentType Value for Content-Type HTTP header.\n     */\n    setRequestContentType(contentType) {\n      this.push(['setRequestContentType', contentType]);\n    }\n    /**\n     * Disable the feature which groups together multiple tracking requests and send them as a bulk POST request.\n     * <p/>\n     * Disabling this feature is useful when you want to be able to replay all logs:\n     * one must use disableQueueRequest to disable this behaviour to later be able to replay logged\n     * Matomo logs (otherwise a subset of the requests wouldn't be able to be replayed).\n     */\n    disableQueueRequest() {\n      this.push(['disableQueueRequest']);\n    }\n    /**\n     * Defines after how many ms a queued requests will be executed after the request was queued initially\n     * <p/>\n     * The higher the value the more tracking requests can be sent together at once\n     *\n     * @param interval Interval in milliseconds, must be at least 1000, defaults to 2500\n     */\n    setRequestQueueInterval(interval) {\n      this.push(['setRequestQueueInterval', interval]);\n    }\n    /** Disable sending tracking requests using `navigator.sendBeacon` which is enabled by default */\n    disableAlwaysUseSendBeacon() {\n      this.push(['disableAlwaysUseSendBeacon']);\n    }\n    /** Enable sending tracking requests using `navigator.sendBeacon` (enabled by default) */\n    alwaysUseSendBeacon() {\n      this.push(['alwaysUseSendBeacon']);\n    }\n    /**\n     * Enable Javascript errors tracking. JS errors are then tracked as events with category\n     * \"JavaScript Errors\". Refer to official doc for more details.\n     *\n     * @see https://matomo.org/faq/how-to/how-do-i-enable-basic-javascript-error-tracking-and-reporting-in-matomo-browser-console-error-messages/\n     */\n    enableJSErrorTracking() {\n      this.push(['enableJSErrorTracking']);\n    }\n    /**\n     * Enable tracking of file:// protocol actions. By default, the file:// protocol is not tracked.\n     */\n    enableFileTracking() {\n      this.push(['enableFileTracking']);\n    }\n    /** Asynchronously call provided method name on matomo tracker instance */\n    get(getter) {\n      return this.pushFn(matomo => matomo[getter]());\n    }\n  }\n  MatomoTracker.ɵfac = function MatomoTracker_Factory(t) {\n    return new (t || MatomoTracker)();\n  };\n  MatomoTracker.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: MatomoTracker,\n    factory: function MatomoTracker_Factory(t) {\n      let r = null;\n      if (t) {\n        r = new t();\n      } else {\n        r = createMatomoTracker(i0.ɵɵinject(INTERNAL_MATOMO_CONFIGURATION), i0.ɵɵinject(PLATFORM_ID), i0.ɵɵinject(NgZone));\n      }\n      return r;\n    },\n    providedIn: 'root'\n  });\n  return MatomoTracker;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass StandardMatomoTracker extends MatomoTracker {\n  constructor(ngZone, config) {\n    super();\n    this.ngZone = ngZone;\n    this.config = config;\n    initializeMatomoHolder();\n  }\n  pushFn(fn) {\n    return new Promise(resolve => {\n      this.push([function () {\n        resolve(fn(this));\n      }]);\n    });\n  }\n  push(args) {\n    if (this.config.runOutsideAngularZone) {\n      this.ngZone.runOutsideAngular(() => {\n        window._paq.push(trimTrailingUndefinedElements(args));\n      });\n    } else {\n      window._paq.push(trimTrailingUndefinedElements(args));\n    }\n  }\n}\nclass NoopMatomoTracker extends MatomoTracker {\n  push(args) {\n    // No-op\n  }\n  pushFn(fn) {\n    return Promise.reject('MatomoTracker is disabled');\n  }\n}\nconst DEFAULT_BORDER = '0';\nconst DEFAULT_WIDTH = '600px';\nconst DEFAULT_HEIGHT = '200px';\nconst URL_PATTERN = '{SERVER}/index.php?module=CoreAdminHome&action=optOut&language={LOCALE}&backgroundColor={BG_COLOR}&fontColor={COLOR}&fontSize={FONT_SIZE}&fontFamily={FONT_FAMILY}';\nfunction missingServerUrlError() {\n  return new Error('It is required to set [serverUrl] when Matomo configuration mode is set to MANUAL');\n}\n/**\n * Basic opt-out form, based on an iframe auto-generated by Matomo.\n *\n * <b>WARNING:</b> By default, this component assumes the tracker url set in MatomoConfiguration is\n * safe to be used as an iframe `src`. You have to make sure that this url is safe before using this\n * component!\n */\nlet MatomoOptOutFormComponent = /*#__PURE__*/(() => {\n  class MatomoOptOutFormComponent {\n    constructor(sanitizer, config, locale = '') {\n      this.sanitizer = sanitizer;\n      this.config = config;\n      this._border = DEFAULT_BORDER;\n      this._width = DEFAULT_WIDTH;\n      this._height = DEFAULT_HEIGHT;\n      this._iframeSrc = this.sanitizer.bypassSecurityTrustResourceUrl('');\n      /** Font color (note that Matomo currently only supports hexadecimal without leading hash notation) */\n      this.color = '';\n      /** Background color (note that Matomo currently only supports hexadecimal without leading hash notation) */\n      this.backgroundColor = '';\n      this.fontSize = '';\n      this.fontFamily = '';\n      // Set default locale\n      this.locale = locale;\n      if (isAutoConfigurationMode(this.config) && isExplicitTrackerConfiguration(this.config)) {\n        this._defaultServerUrl = getTrackersConfiguration(this.config)[0].trackerUrl;\n      }\n    }\n    get serverUrl() {\n      return this._serverUrlOverride;\n    }\n    /**\n     * Set a custom Matomo server url to be used for iframe generation\n     * <br>\n     * By default, tracker url is retrieved from MatomoConfiguration.\n     * <br>\n     * <b>WARNING:</b> This component assumes the url you provide is safe to be used as an iframe\n     * `src`. You have to make sure that this url is safe before using this component!\n     */\n    set serverUrl(value) {\n      this._serverUrlOverride = value;\n    }\n    get iframeSrc() {\n      return this._iframeSrc;\n    }\n    get height() {\n      return this._height;\n    }\n    set height(value) {\n      this._height = coerceCssSizeBinding(value);\n    }\n    get width() {\n      return this._width;\n    }\n    set width(value) {\n      this._width = coerceCssSizeBinding(value);\n    }\n    get border() {\n      return this._border;\n    }\n    set border(value) {\n      this._border = coerceCssSizeBinding(value);\n    }\n    ngOnInit() {\n      this.updateUrl();\n    }\n    ngOnChanges(changes) {\n      if ('serverUrl' in changes || 'locale' in changes || 'color' in changes || 'backgroundColor' in changes || 'fontSize' in changes || 'fontFamily' in changes) {\n        this.updateUrl();\n      }\n    }\n    updateUrl() {\n      let serverUrl = this._defaultServerUrl;\n      if (this._serverUrlOverride) {\n        serverUrl = this.sanitizer.sanitize(SecurityContext.RESOURCE_URL, this._serverUrlOverride);\n      }\n      if (!serverUrl) {\n        throw missingServerUrlError();\n      }\n      const url = URL_PATTERN.replace('{SERVER}', serverUrl).replace('{LOCALE}', encodeURIComponent(this.locale)).replace('{COLOR}', encodeURIComponent(this.color)).replace('{BG_COLOR}', encodeURIComponent(this.backgroundColor)).replace('{FONT_SIZE}', encodeURIComponent(this.fontSize)).replace('{FONT_FAMILY}', encodeURIComponent(this.fontFamily));\n      this._iframeSrc = this.sanitizer.bypassSecurityTrustResourceUrl(url);\n    }\n  }\n  MatomoOptOutFormComponent.ɵfac = function MatomoOptOutFormComponent_Factory(t) {\n    return new (t || MatomoOptOutFormComponent)(i0.ɵɵdirectiveInject(i1.DomSanitizer), i0.ɵɵdirectiveInject(INTERNAL_MATOMO_CONFIGURATION), i0.ɵɵdirectiveInject(LOCALE_ID, 8));\n  };\n  MatomoOptOutFormComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: MatomoOptOutFormComponent,\n    selectors: [[\"matomo-opt-out-form\"]],\n    inputs: {\n      locale: \"locale\",\n      color: \"color\",\n      backgroundColor: \"backgroundColor\",\n      fontSize: \"fontSize\",\n      fontFamily: \"fontFamily\",\n      serverUrl: \"serverUrl\",\n      height: \"height\",\n      width: \"width\",\n      border: \"border\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 1,\n    vars: 7,\n    consts: [[3, \"src\"]],\n    template: function MatomoOptOutFormComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"iframe\", 0);\n      }\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"border\", ctx.border)(\"width\", ctx.width)(\"height\", ctx.height);\n        i0.ɵɵproperty(\"src\", ctx.iframeSrc, i0.ɵɵsanitizeResourceUrl);\n      }\n    },\n    encapsulation: 2\n  });\n  return MatomoOptOutFormComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MatomoTrackClickDirective = /*#__PURE__*/(() => {\n  class MatomoTrackClickDirective {\n    constructor(tracker) {\n      this.tracker = tracker;\n    }\n    onClick() {\n      this.tracker.trackEvent(requireNonNull(this.matomoClickCategory, 'matomo category is required'), requireNonNull(this.matomoClickAction, 'matomo action is required'), this.matomoClickName, this.matomoClickValue);\n    }\n  }\n  MatomoTrackClickDirective.ɵfac = function MatomoTrackClickDirective_Factory(t) {\n    return new (t || MatomoTrackClickDirective)(i0.ɵɵdirectiveInject(MatomoTracker));\n  };\n  MatomoTrackClickDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: MatomoTrackClickDirective,\n    selectors: [[\"\", \"matomoClickCategory\", \"\", \"matomoClickAction\", \"\"]],\n    hostBindings: function MatomoTrackClickDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function MatomoTrackClickDirective_click_HostBindingHandler() {\n          return ctx.onClick();\n        });\n      }\n    },\n    inputs: {\n      matomoClickCategory: \"matomoClickCategory\",\n      matomoClickAction: \"matomoClickAction\",\n      matomoClickName: \"matomoClickName\",\n      matomoClickValue: \"matomoClickValue\"\n    }\n  });\n  return MatomoTrackClickDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction coerceEventNames(input) {\n  if (input && input.length > 0) {\n    return Array.isArray(input) ? input : [input];\n  } else {\n    return undefined;\n  }\n}\nlet MatomoTrackerDirective = /*#__PURE__*/(() => {\n  class MatomoTrackerDirective {\n    constructor(tracker, elementRef) {\n      this.tracker = tracker;\n      this.elementRef = elementRef;\n    }\n    /** Track a Matomo event whenever specified DOM event is triggered */\n    set matomoTracker(input) {\n      const eventNames = coerceEventNames(input);\n      this.sub?.unsubscribe();\n      if (eventNames) {\n        const handlers = eventNames.map(eventName => fromEvent(this.elementRef.nativeElement, eventName));\n        this.sub = merge(...handlers).subscribe(() => this.trackEvent());\n      } else {\n        this.sub = undefined;\n      }\n    }\n    ngOnDestroy() {\n      this.sub?.unsubscribe();\n    }\n    trackEvent(arg1, arg2) {\n      let category = this.matomoCategory;\n      let action = this.matomoAction;\n      let name = this.matomoName;\n      let value = this.matomoValue;\n      if (typeof arg1 === 'object') {\n        category = arg1.category ?? category;\n        action = arg1.action ?? action;\n        name = arg1.name ?? name;\n        value = arg1.value ?? value;\n      } else if (typeof arg1 === 'string') {\n        name = arg1;\n        if (typeof arg2 === 'number') {\n          value = arg2;\n        }\n      } else if (typeof arg1 === 'number') {\n        value = arg1;\n      }\n      this.tracker.trackEvent(requireNonNull(category, 'matomo category is required'), requireNonNull(action, 'matomo action is required'), name, value);\n    }\n  }\n  MatomoTrackerDirective.ɵfac = function MatomoTrackerDirective_Factory(t) {\n    return new (t || MatomoTrackerDirective)(i0.ɵɵdirectiveInject(MatomoTracker), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n  MatomoTrackerDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: MatomoTrackerDirective,\n    selectors: [[\"\", \"matomoTracker\", \"\"]],\n    inputs: {\n      matomoCategory: \"matomoCategory\",\n      matomoAction: \"matomoAction\",\n      matomoName: \"matomoName\",\n      matomoValue: \"matomoValue\",\n      matomoTracker: \"matomoTracker\"\n    },\n    exportAs: [\"matomo\"]\n  });\n  return MatomoTrackerDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst createDefaultMatomoScriptElement = (scriptUrl, document) => {\n  const g = document.createElement('script');\n  g.type = 'text/javascript';\n  g.defer = true;\n  g.async = true;\n  g.src = scriptUrl;\n  return g;\n};\nconst MATOMO_SCRIPT_FACTORY = new InjectionToken('MATOMO_SCRIPT_FACTORY', {\n  providedIn: 'root',\n  factory: () => createDefaultMatomoScriptElement\n});\nconst ALREADY_INJECTED_ERROR = 'Matomo trackers have already been initialized';\nconst ALREADY_INITIALIZED_ERROR = 'Matomo has already been initialized';\nfunction coerceSiteId(siteId) {\n  return `${siteId}`;\n}\nfunction appendTrailingSlash(str) {\n  return str.endsWith('/') ? str : `${str}/`;\n}\nfunction buildTrackerUrl(url, suffix) {\n  if (suffix == null) {\n    return appendTrailingSlash(url) + DEFAULT_TRACKER_SUFFIX;\n  }\n  return url + suffix;\n}\nconst DEFAULT_TRACKER_SUFFIX = 'matomo.php';\nconst DEFAULT_SCRIPT_SUFFIX = 'matomo.js';\nfunction createMatomoInitializer(config, tracker, scriptFactory, document, platformId) {\n  return config.disabled || !isPlatformBrowser(platformId) ? new NoopMatomoInitializer() : new MatomoInitializerService(config, tracker, scriptFactory, document);\n}\nclass NoopMatomoInitializer {\n  initialize() {\n    // No-op\n  }\n  initializeTracker(_) {\n    // No-op\n  }\n}\nlet MatomoInitializerService = /*#__PURE__*/(() => {\n  class MatomoInitializerService {\n    constructor(config, tracker, scriptFactory, document) {\n      this.config = config;\n      this.tracker = tracker;\n      this.scriptFactory = scriptFactory;\n      this.document = document;\n      this.initialized = false;\n      this.injected = false;\n      initializeMatomoHolder();\n    }\n    /** @deprecated use {@link initialize initialize()} instead */\n    init() {\n      this.initialize();\n    }\n    initialize() {\n      if (this.initialized) {\n        throw new Error(ALREADY_INITIALIZED_ERROR);\n      }\n      this.runPreInitTasks();\n      if (isAutoConfigurationMode(this.config)) {\n        this.injectMatomoScript(this.config);\n      }\n      this.initialized = true;\n    }\n    initializeTracker(config) {\n      this.injectMatomoScript(config);\n    }\n    injectMatomoScript(config) {\n      if (this.injected) {\n        throw new Error(ALREADY_INJECTED_ERROR);\n      }\n      if (isExplicitTrackerConfiguration(config)) {\n        const {\n          scriptUrl: customScriptUrl\n        } = config;\n        const [mainTracker, ...additionalTrackers] = getTrackersConfiguration(config);\n        const scriptUrl = customScriptUrl ?? appendTrailingSlash(mainTracker.trackerUrl) + DEFAULT_SCRIPT_SUFFIX;\n        this.registerMainTracker(mainTracker);\n        this.registerAdditionalTrackers(additionalTrackers);\n        this.injectDOMScript(scriptUrl);\n      } else if (isEmbeddedTrackerConfiguration(config)) {\n        const {\n          scriptUrl,\n          trackers: additionalTrackers\n        } = {\n          trackers: [],\n          ...config\n        };\n        this.registerAdditionalTrackers(additionalTrackers);\n        this.injectDOMScript(scriptUrl);\n      }\n      this.injected = true;\n    }\n    registerMainTracker(mainTracker) {\n      const mainTrackerUrl = buildTrackerUrl(mainTracker.trackerUrl, mainTracker.trackerUrlSuffix);\n      const mainTrackerSiteId = coerceSiteId(mainTracker.siteId);\n      this.tracker.setTrackerUrl(mainTrackerUrl);\n      this.tracker.setSiteId(mainTrackerSiteId);\n    }\n    registerAdditionalTrackers(additionalTrackers) {\n      additionalTrackers.forEach(({\n        trackerUrl,\n        siteId,\n        trackerUrlSuffix\n      }) => {\n        const additionalTrackerUrl = buildTrackerUrl(trackerUrl, trackerUrlSuffix);\n        const additionalTrackerSiteId = coerceSiteId(siteId);\n        this.tracker.addTracker(additionalTrackerUrl, additionalTrackerSiteId);\n      });\n    }\n    injectDOMScript(scriptUrl) {\n      const scriptElement = this.scriptFactory(scriptUrl, this.document);\n      const selfScript = requireNonNull(this.document.getElementsByTagName('script')[0], 'no existing script found');\n      const parent = requireNonNull(selfScript.parentNode, \"no script's parent node found\");\n      parent.insertBefore(scriptElement, selfScript);\n    }\n    runPreInitTasks() {\n      if (this.config.acceptDoNotTrack) {\n        this.tracker.setDoNotTrack(true);\n      }\n      if (this.config.requireConsent === MatomoConsentMode.COOKIE) {\n        this.tracker.requireCookieConsent();\n      } else if (this.config.requireConsent === MatomoConsentMode.TRACKING) {\n        this.tracker.requireConsent();\n      }\n      if (this.config.enableJSErrorTracking) {\n        this.tracker.enableJSErrorTracking();\n      }\n      if (this.config.trackAppInitialLoad) {\n        this.tracker.trackPageView();\n      }\n      if (this.config.enableLinkTracking) {\n        this.tracker.enableLinkTracking();\n      }\n    }\n  }\n  MatomoInitializerService.ɵfac = function MatomoInitializerService_Factory(t) {\n    i0.ɵɵinvalidFactory();\n  };\n  MatomoInitializerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: MatomoInitializerService,\n    factory: function MatomoInitializerService_Factory(t) {\n      let r = null;\n      if (t) {\n        r = new t();\n      } else {\n        r = createMatomoInitializer(i0.ɵɵinject(INTERNAL_MATOMO_CONFIGURATION), i0.ɵɵinject(MatomoTracker), i0.ɵɵinject(MATOMO_SCRIPT_FACTORY), i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(PLATFORM_ID));\n      }\n      return r;\n    },\n    providedIn: 'root'\n  });\n  return MatomoInitializerService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgxMatomoTrackerModule = /*#__PURE__*/(() => {\n  class NgxMatomoTrackerModule {\n    constructor(initializer, parent) {\n      this.initializer = initializer;\n      if (!parent) {\n        // Do not initialize if it is already (by a parent module)\n        this.initializer.initialize();\n      }\n    }\n    static forRoot(config, scriptFactory) {\n      const providers = [{\n        provide: MATOMO_CONFIGURATION,\n        useValue: config\n      }];\n      if (scriptFactory) {\n        providers.push({\n          provide: MATOMO_SCRIPT_FACTORY,\n          useValue: scriptFactory\n        });\n      }\n      return {\n        ngModule: NgxMatomoTrackerModule,\n        providers\n      };\n    }\n  }\n  NgxMatomoTrackerModule.ɵfac = function NgxMatomoTrackerModule_Factory(t) {\n    return new (t || NgxMatomoTrackerModule)(i0.ɵɵinject(MatomoInitializerService), i0.ɵɵinject(NgxMatomoTrackerModule, 12));\n  };\n  NgxMatomoTrackerModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NgxMatomoTrackerModule\n  });\n  NgxMatomoTrackerModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return NgxMatomoTrackerModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/*\n * Public API Surface of tracker\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { INTERNAL_MATOMO_CONFIGURATION, MATOMO_CONFIGURATION, MATOMO_SCRIPT_FACTORY, MatomoConsentMode, MatomoInitializationMode, MatomoInitializerService, MatomoOptOutFormComponent, MatomoTrackClickDirective, MatomoTracker, MatomoTrackerDirective, NgxMatomoTrackerModule, createDefaultMatomoScriptElement };\n//# sourceMappingURL=ngx-matomo-tracker.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}